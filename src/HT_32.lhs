================================================================================
                СИЛЬНЫЕ СТОРОНЫ ФУНКЦИОНАЛЬНОГО ПРОГРАММИРОВАНИЯ

                Джон Хьюз
                John Hughes - Chalmers University of Technology
================================================================================
  
> module JH_32 where

-- /////////////////////////////////////////////////////////////////////////////

3.2.	Численное дифференцирование

Мы повторно использовали iterate при генерации последовательности приближений в вычислениях 
квадратного корня. Конечно же, можно многократно использовать 
within и relative в любых численных алгоритмах, которые генерирует последовательность 
приближений. Сделаем это в алгоритме численного дифференцирования.
Производная функции в точке -- наклон графика функции в этой точке. Е╦ можно легко найти, 
определив значение функции в данной точке и в другой точке поблизости и вычислив наклон 
прямой линии между двумя точками. Предполагается, что, если две точки находятся 
достаточно близко, то график функции между ними не будет слишком изгибаться. 
Это дает определение:

> easydiff f x h = (f (x + h) - f x) / h

Чтобы получить хорошее приближение, значение h должно быть очень маленьким. К сожалению, 
если h слишком маленькое, то два значения f (x + h) и f (x) -- очень близки друг другу, 
так что ошибка округления при вычитании может заглушать результат. Как правильно 
выбрать значение h? Одно решение этой дилеммы -- вычислять последовательность приближений 
со все меньшими и меньшими значениями h, начиная с разумно большого. Такая 
последовательность должна сходиться к значению производной, но станет безнадежно неточной 
в конечном счете из-за ошибок округления.
Если (within eps) используется, чтобы выбрать первое приближение, которое достаточно точно, 
то риск ошибки округления, воздействующей на результат можно уменьшить. Мы нуждаемся в функции, 
вычисляющей последовательность:

> differentiate h0 f x = map (easydiff f x) (iterate halve h0)
> halve x = x / 2

Где h0 -- начальное значение h, последовательные значения получены повторным делением на два. 
С помощью этой функции, производная в любой точке может быть вычислена так:

within eps (differentiate h0 f x)

Но это решение не вполне удовлетворительно, потому что последовательность приближений 
сходится довольно медленно. Немного простой математики может нам помочь. Элементы 
последовательности могут быть выражены как правильный ответ + погрешность, относящаяся к h.
Можно показать теоретически, что член погрешности грубо пропорционален степени h. 
Пусть A -- правильный ответ и B * hn -- ошибка. Так как каждое последующее приближение 
вычислено, используя значение h вдвое меньшее того, что было использовало для предыдущего, 
любые два последовательных приближения могут быть выражены как 
ai = A + B * hn и ai + 1 = A + B * hn / 2n. Теперь член погрешности может быть устран╦н:
	A = (ai + 1 * 2n - ai ) / 2n - 1	(4.2)
Конечно, ошибка определяется степенью h только при грубом приближении. Поэтому наше 
заключение также приблизительно, но вс╦ равно, это намного лучшее приближение. Подобное 
усовершенствование может применяться ко всем последовательным парам приближений, 
с помощью функции

> elimerror n (a : b : rest) =
>                        (b * 2 ^ n - a) / (2 ^ n - 1) : elimerror n (b : rest)

которая устраняет погрешность из последовательности приближений и выда╦т другую 
последовательность, сходящуюся намного быстрее.
Но одна проблема оста╦тся. Прежде, чем мы можем использовать elimerror -- мы должны знать 
значение n. Его трудно предсказать, но можно измерить. Нетрудно показать, что следующая 
оценка правильна, но не будем приводить доказательства.
	n = round log2 (ai + 2 - ai) / (aii + 1 - ai) - 1	(4.3)

order a : b : c : rest = round log2 (a - c) / (b - c) - 1

Теперь можно определить общую функцию, улучшающую последовательность приближений:

> improve s = elimerror (order s) s

Производную функции f можно вычислить более эффективно, используя improve следующим образом:
within eps (improve (differentiate h0 f x))
Отметим что improve подходит только для последовательностей приближений, которые вычислены 
с использованием параметра h, делимого на два при каждом шаге. Однако, если она применена 
к такой последовательности, ее результат -- такая же последовательность! Это означает, 
что последовательность приближений может быть улучшена больше чем однажды. Каждый раз 
погрешность устраняется, и последовательности сходятся вс╦ быстрее и быстрее. Производную 
можно вычислить очень эффективно используя:
within eps (improve (improve (improve (differentiate h0 f x))))
В терминах вычислительной математики это, вероятно, будет методом четв╦ртого порядка, и да╦т 
точный результат очень быстро. Можно даже определить:

> super s = map second (iterate improve s)
> second (a : b : rest) = b

Здесь super использует (iterate improve), чтобы получить последовательность вс╦ более улучшенных 
последовательностей приближений, и строит новую последовательность приближений, беря второе 
приближение каждой из улучшенных последовательностей (оказывается, что лучше всего брать 
второе -- оно более точно чем первое и не требует дополнительных вычислений). Этот алгоритм 
действительно очень сложный -- он использует все лучший и лучший численный метод, по мере 
того как все больше приближений вычислено. Производные можно очень эффективно вычислять программой:

within eps (super (differentiate h0 f x))

Вероятно, это похоже на использование кувалды, чтобы расколоть орех, но смысл в том, что даже 
столь сложный алгоритм как super легко выражается путем модуляризации с использованием ленивых 
вычислений.

================================================================================
 

