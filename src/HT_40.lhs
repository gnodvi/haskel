================================================================================
                СИЛЬНЫЕ СТОРОНЫ ФУНКЦИОНАЛЬНОГО ПРОГРАММИРОВАНИЯ

                Джон Хьюз
                John Hughes - Chalmers University of Technology
================================================================================
 
> module JH_40 where

-- /////////////////////////////////////////////////////////////////////////////

4.   ПРИМЕР ИЗ ИСКУССТВЕННОГО ИНТЕЛЛЕКТА

Мы утверждали, что функциональные языки мощны, прежде всего, потому что они обеспечивают два 
новых типа связующих элементов: функции более высокого порядка и ленивые вычисления. Возьмем 
пример из ╚искусственного интеллекта╩ и покажем, что его очень просто можно запрограммировать, 
используя эти два вида типов связующих элементов.
    Пример, который мы выбираем -- ╚альфа-бета эвристика╩, алгоритм для оценки позиции в которой 
находится игрок. Алгоритм работает, просматривая возможные ходы, чтобы видеть, как игра могла 
бы развиваться, но избегает анализа невыгодных вариантов.
    Пусть позиции в игре представлены объектами типа position. Это тип изменяется от игры к игре, 
и мы о н╦м ничего не предполагаем. Но должен существовать некоторый метод для того, чтобы 
узнать, какие ходы могут быть сделаны в данной позиции. Предположим, что имеется функция:

> moves :: Position -> [Position]

Эта функция получает игровую позицию как параметр и возвращает список всех позиций, которые 
могут быть достигнуты в один ход. Предполагается, что всегда можно узнать из позиции, чья очередь 
хода. В крестиках-ноликах это можно сделать, подсчитав крестики и нолики. В игре, подобной 
шахматам, информация должна быть явно включена в тип Position.

Прежде всего надо сформировать дерево игры. Это дерево, в котором узлы помечены позициями, 
так что дочерние элементы узла помечены позициями, которые могут быть достигнуты в один ход 
из этого узла. То есть если узел помечен позицией p, то его дочерние элементы помечены позициями 
(moves p). Дерево может быть бесконечным. Игровые деревья подобны деревьям, которые мы обсуждали 
в разделе 2 -- каждый узел имеет метку (т.е. позицию) и список подузлов. Поэтому мы можем 
использовать для их представления тот же самый тип данных.
    Дерево игры формируется повторными применениями moves. Начиная с корневой позиции, moves 
используются, чтобы генерировать метки для поддеревьев корня. Затем moves используются снова, 
чтобы генерировать поддеревья поддеревьев и так далее. Этот рекурсивный образец может быть 
выражен функцией высшего порядка:

> reptree f a = Node a (map (reptree f) (f a))

Используя эту функцию можно определить другую функцию, которая создает игровое дерево, начиная 
со специфической позиции:

> gametree p = reptree moves p

Функция высшего порядка, используемая здесь (reptree) аналогична функции iterate, создававшей 
бесконечные списки в предыдущем разделе.
    Алгоритм просматривает дерево игры, начиная с данной позиции, пытаясь определить, насколько 
благоприятно будет развиваться игра. Но чтобы сделать это, он должен иметь возможность делать 
грубую оценку значения позиции без просмотра впер╦д. Эта ╚статическая оценка╩ должна 
использоваться на границах просмотра вперед. Результат статической оценки является мерой обещания 
позиции с точки зрения компьютера (предполагается, что компьютер играет против человека). 
Чем больше результат, тем лучше позиция для компьютера. В самом простом случае такая функция 
возвращает +1 для позиций, где компьютер уже победил, -1 для позиций, где компьютер уже проиграл, 
и 0 в остальных случаях. В действительности, функция статической оценки измеряет различные вещи, 
которые делают позицию ╚хорошей╩, например, материальное преимущество и контроль центра в шахматах. 
Предположим, что мы имеем такую функцию:

> static: Position -> Number

Так как игровое дерево есть Treeof Position, оно может быть преобразовано в Treeof Number функцией 
(maptree static), которая статически вычисляет все позиции в дереве (их может быть бесконечно много). 
Здесь используется функция maptree, определенная в разделе 2.

Как найти ╚истинные╩ значения позиций из такого дерева статических оценок? В частности какое 
значение должно быть приписано корневой позиции? Ее статическое значение -- только грубое 
предположение. Значение, приписанное узлу, должно определятся из значений его подузлов. Это может 
быть сделано в предположении, что каждый игрок делает лучшие ходы. Поскольку высокое значение 
означает хорошую позицию для компьютера, ясно что, он выберет ход, ведущий к подузлу с максимальным 
значением. Точно так же противник выберет ход к подузлу с минимальным значением. Значение узла 
вычисляются функцией maximise, если очередь компьютера и minimise, иначе:

> maximise (Node n sub) = maximum (map minimise sub)
> minimise (Node n sub) = minimum (map maximise sub)

Здесь maximum и minimum -- функции на списках чисел, которые возвращают максимум и минимум списка 
соответственно. Эти определения не закончены, потому что они будут зацикливаться -- нет базового 
случая. Мы должны определить значение узла без преемников, и мы определяем его как статическую 
оценку узла. Статическая оценка используется когда игрок уже выиграл, или на границах просмотра. 
Законченные определения maximise и minimise:

> maximise (Node n []) = n
> maximise (Node n sub) = maximum (map minimise sub)
> minimise (Node n []) = n
> minimise (Node n sub) = minimum (map maximise sub)

Уже можно было бы записать функцию, которая возвращает значение позиции:

> evaluate = maximise . maptree static . gametree

Имеются две проблемы с этим определением. Прежде всего, оно не работает для бесконечных деревьев. 
Функция maximise продолжает рекурсивно вызываться, пока не находит узла без поддеревьев -- 
конец дерева. Если нет никакого конца, то maximise не вернет никакого результата. Вторая проблема 
связана с первой -- даже конечные игровые деревья могут быть очень большими. Нереалистично 
пытаться оценить игровое дерево целиком -- поиск должен быть ограничен следующими немногими 
ходами. Это можно сделать, обрезая дерево до установленной глубины:

> prune 0 (Node a x) = Node a []
> prune n (Node a x) = Node a (map (prune (n - 1)) x)

Функция (prune n) бер╦т дерево и ╚вырезает╩ все узлы, расположенные далее, чем на n от корня. 
Если дерево обрезано, maximise будет использовать статическую оценку для узлов глубины n. 
Поэтому evaluate можно определить так:

> evaluate = maximise . maptree static . prune 5 . gametree

    Что просматривает (скажем) на 5 шагов впер╦д.
Уже здесь мы использовали функции высшего порядка и ленивые вычисления. Функции высшего 
порядка 
reptree и maptree позволяют нам с легкостью создавать и управлять игровыми деревьями. Более 
важно то, что ленивые вычисления разрешает нам модуляризировать вычисления таким образом.

Поскольку функция gametree выдает потенциально бесконечный результат, эта программа никогда 
не закончилась бы без ленивых вычислений. Вместо (prune 5 . gametree) мы были бы должны 
свернуть эти две функции вместе в одну такую, которая создавала бы только первые пять уровней 
дерева. Но даже дерево первых пяти уровней может быть слишком большим, чтобы разместиться 
в памяти. В программе которую мы написали, функция (maptree static . prune 5 . gametree) 
создает только те части дерева, которые требует maximise. Так как каждая часть может быть 
удалена (сборщиком мусора), как только maximise покончит с ней, дерево никогда не находится 
в памяти целиком. Только маленькая часть дерева хранится в один момент времени. Поэтому 
ленивая программа эффективна. Поскольку эта эффективность зависит от взаимодействия между 
maximise (последняя функция в цепочке) и gametree (первая), ее можно получить без ленивых 
вычислений только сворачивая все функции цепочки вместе в одну большую. Это значительно 
уменьшает модульность, но именно это обычно и делается. Мы можем сделать усовершенствования 
этого несерьезного алгоритма оценки. Для каждой его части это относительно просто. Обычный 
программист должен изменить всю программу целиком, что намного сложнее.

Пока мы описали только простой минимаксный алгоритм. Основа альфа-бета алгоритма -- наблюдение, 
что часто можно вычислить значение maximise или minimise без просмотра целого дерева. 
Рассмотрим дерево:

      max
     /   \
  min     min
  / \     / \
 1   2   0   ?

Нет необходимости знать значение (?), чтобы оценить дерево. Левый минимум равен 1, но правый 
минимум явно меньше или равен 0. Поэтому максимум из этих двух минимумов должен быть 1. Это 
наблюдение может быть обобщено и встроено в maximise и minimise. Первый шаг -- выделить применение
minimise к списку чисел, то есть мы разлагаем, maximise как:

> maximise = maximum . maximise'

(Функция minimise, разбивается подобным образом. Так как minimise и maximise полностью 
симметричны, мы обсудим maximise и предполагаем, что minimise обрабатывается так же). 
Раздел╦нная таким образом maximise может использовать minimise' а не minimise, чтобы определить, 
для каких чисел minimise, будет искать минимум. Тогда можно отказаться от некоторых чисел не 
глядя на них. Благодаря ленивым вычислениям, если maximise не просматривает весь список чисел, 
некоторые из них не будет вычислены, с потенциальным сохранением времени вычислений.

Несложно ╚вынести за скобки╩ maximum из определения maximise:

> maximise' (Node n [])	= n : []
> maximise' (Node n l)	= map minimise l
> 					= map (minimum . minimise') l
> 					= map minimum (map minimise' l)
> 					= mapmin (map minimise' l)
> 						where mapmin = map minimum

Так как minimise' возвращает список чисел, минимум которых -- результат minimise, 
то (map minimise' l) возвращает список списков чисел. Функция maximise' должна возвратить 
список минимумов этих списков. Однако, только максимум этого списка имеет значение. 
Мы определим новую версию mapmin, которая опускает минимумы тех списков, чей минимум не имеет 
значения:

> mapmin nums : rest = min nums : omit min nums rest

Функция omit получает ╚потенциальный максимум╩ -- самый большой, из замеченных на данный 
момент минимумов -- и опускает любые минимумы, которые меньше его.

> omit pot [] = []
> omit pot (nums : rest) =	if minleq nums pot
> 						then omit pot rest
> 						else (minimum nums) : omit (minimum nums) rest

Функция minleq получает список чисел и потенциальный максимум, и возвращает истину если минимум 
списка чисел меньше или равен потенциальному максимуму. Чтобы сделать это, не требуется 
смотреть на весь список! Если имеется любой элемент в списке меньший или равный потенциальному 
максимуму, то это -- минимум списка. Все элементы после этого несущественны, они обозначены 
знаком (?) в примере выше. Поэтому minleq может быть определен следующим образом:

> minleq [] pot = False
> minleq (num:rest) pot = num <= pot || minleq rest pot

Определив maximise' и minimise', можно просто записать новую evaluate:

> evaluate = maximum . maximise' . maptree static . prune 8 . gametree

Благодаря ленивым вычислениям, если maximise' просматривает меньшую часть дерева то и вся 
программа выполняется более эффективно. То, что prune просматривает только часть бесконечного 
дерева, дает возможность программе закончиться. Оптимизация maximise' хоть и довольно проста, 
но может оказать значительное воздействие на быстродействие, и позволяет просматривать 
намного дальше.
    Можно сделать и другие улучшения. Например, альфа-бета алгоритм работает лучше всего, если 
сначала рассматриваются лучшие ходы, так как, если найден очень хороший ход то, нет 
необходимости рассматривать худшие ходы, только для того, чтобы продемонстрировать, что 
противник имеет по крайней мере один хороший ответ на них. Можно было бы, поэтому, сортировать 
поддеревья в каждом узле, помещая в начале узлы с самыми высокими значениями оценки, при ходе 
компьютера, и с самыми низкими в противном случае. Это может быть сделано функциями:

> lowfirst (Node n sub) = Node n (sort (map highfirst sub )))
> highfirst (Node n sub) = Node n (reverse (sort (map lowfirst sub ))

Где sort -- универсальная функция сортировки. Теперь можно определить:

> evaluate = max . maximise' . highfirst . maptree static . prune 8 . gametree

Может оказаться достаточно рассматривать только три лучших хода компьютера или противника, 
чтобы ограничить поиск. Чтобы запрограммировать это, надо только заменить highfirst на 
(taketree 3 . highfirst), где

> taketree n = redtree (nodett n) (:) []
> nodett n x sub = Node x (take n sub)

Функция taketree заменяет все узлы в дереве узлами содержащими не более n подузлов, используя 
функцию (take n), которая возвращает первые n элементов списка (или меньшее количество 
если список короче чем n).
    Еще одно улучшение -- усовершенствование отсечений. Программа просматривает на установленную 
глубину, даже если позиция очень динамическая. Например в шахматах она может прекратить 
просмотр в позиции, в которой ферзь находится под боем. Обычно определяются некоторые 
╚динамические╩ позиции в которых нельзя прерывать просмотр. Предположив что функция dynamic 
распознает такие позиции, мы должны добавить только одно уравнение для prune:

> prune 0 (Node pos sub) | dynamic pos = Node pos (map (prune 0) sub)

Легко вносить такие изменения если программа столь же модульная, как эта. Как мы отмечали выше, 
эффективность программы кардинально зависит от взаимодействия между maximise и gametree 
(то есть между первой и последней функциями в цепочке), без ленивых вычислений она может быть 
написана только как монолитная программа, которую трудно написать, очень трудно изменять и 
чрезвычайно трудно понять.

================================================================================
