================================================================================
                СИЛЬНЫЕ СТОРОНЫ ФУНКЦИОНАЛЬНОГО ПРОГРАММИРОВАНИЯ

                Джон Хьюз
                John Hughes - Chalmers University of Technology
================================================================================
 
> module JH_31 where

-- /////////////////////////////////////////////////////////////////////////////

3.1.	Вычисление квадратного корня методом Ньютона   Рафсона

Мы проиллюстрируем мощь ленивых вычислений, программируя некоторые численные алгоритмы. 
Прежде всего, рассмотрим алгоритм Ньютона   Рафсона для вычисления квадратного корня. 
Этот алгоритм вычисляет квадратный корень числа z, начиная с начального приближения a0. 
Он уточняет это значение на каждом последующем шаге, используя правило:
	an + 1 = (an + z/an) / 2	(4.1)
Если приближения сходятся к некоторому пределу a, то a = (a + z/a) / 2 , 
то есть a * a = z или a = squareroot (z)

Фактически сведение к пределу проходит быстро. Программа проводит проверку на точность (eps) 
и останавливается, когда два последовательных приближения отличаются меньше чем на eps. 

При императивном подходе алгоритм обычно программируется следующим образом:
x = a0;
do
{
	 y = x;
	 x = (x + z / x) / 2;
}
while ( abs (x - y) < eps)
// теперь x = квадратному корню из z

Эта программа неделима на обычных языках. Мы выразим е╦ в более модульной форме, используя 
ленивые вычисления, и затем покажем некоторые другие применения полученным частям.
Так как алгоритм Ньютона   Рафсона вычисляет последовательность приближений, естественно 
представить это в программе явно списком приближений. Каждое приближение получено из 
предыдущего функцией:

> next z x = (x + z / x) / 2

То есть (next z) -- функция, отображающая каждое приближение в следующее. Обозначим эту 
функцию f, тогда последовательность приближений будет: [a0, f a0, f (f a0), f (f (f a0)), ...]. 
Мы можем определить функцию, вычисляющую такую последовательность:

> jh_iterate f x = x : jh_iterate f (f x)

Тогда список приближений можно вычислить так:
jh_iterate (next z) a0
Здесь jh_iterate -- пример функции с ╚бесконечным╩ выводом -- но это не проблема, потому что 
фактически будет вычислено не больше приближений, чем требуется остальным частям программы. 
Бесконечность -- только потенциальная: это означает, что любое число приближений можно вычислить, 
если потребуется, jh_iterate сама по себе не содержит никаких ограничений.
Остаток программы -- функция within, которая берет допуск и список приближений и, просматривая 
список, ищет два последовательных приближения, отличающихся не более чем на данный допуск.

> within eps (a:b:rest) = if abs (a - b) <= eps
>                         then b
>                         else within eps (b : rest)

Собирая части, получаем:

> jh_sqrt a0 eps z = within eps (jh_iterate (next z) a0)

Теперь, когда мы имеем части программы поиска квадратного корня, мы можем попробовать 
объединить их различными способами. Одна из модификаций, которую мы могли бы пожелать, 
заключается в использовании относительной погрешности вместо абсолютной. Она больше подходит 
как для очень малых чисел (когда различие между последовательными приближениями маленькое), 
так и для очень больших (при округлении ошибки могут быть намного большими, чем допуск). 
Необходимо определить только замену для within:

> relative eps (a:b:rest) = if abs (a - b) <= eps * abs (b)
>                           then b
>                           else relative eps (b:rest)

Теперь можно определить новую версию sqrt:

> jh_relativesqrt a0 eps z = relative eps (jh_iterate (next z) a0)

Нет необходимости переписывать часть, которая генерирует приближения.

================================================================================
 

